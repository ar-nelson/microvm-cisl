.typedef @i8 = int<8>
.typedef @i16 = int<16>
.typedef @i32 = int<32>
.typedef @i64 = int<64>
.typedef @float = float
.typedef @double = double

.typedef @void = void

.funcsig @noparamsnoret = @void ()

.funcdef @binops <@void (@i32 @i32)> (%p0 %p1) {
    %add  = ADD  <@i32> %p0 %p1
    %sub  = SUB  <@i32> %p0 %p1
    %mul  = MUL  <@i32> %p0 %p1
    %udiv = UDIV <@i32> %p0 %p1
    %sdiv = SDIV <@i32> %p0 %p1
    %urem = UREM <@i32> %p0 %p1
    %srem = SREM <@i32> %p0 %p1
    %shl  = SHL  <@i32> %p0 %p1
    %lshr = LSHR <@i32> %p0 %p1
    %ashr = ASHR <@i32> %p0 %p1
    %and  = AND  <@i32> %p0 %p1
    %or   = OR   <@i32> %p0 %p1
    %xor  = XOR  <@i32> %p0 %p1
    
    %trap = TRAP <@void> %exit %exit KEEPALIVE (
        %add %sub %mul %udiv %sdiv %urem %srem
        %shl %lshr %ashr %and %or %xor
        )
    
%exit:
    ICALL @uvm.thread_exit ()
    RETVOID // unreachable
}

.funcdef @simplesum <@void (@i64 @i64)> (%from %to) {
%entry:
    BRANCH %head

%head:
    %sum = PHI <@i64> { %entry: 0; %body: %sum2; }
    %i   = PHI <@i64> { %entry: %from; %body: %i2; }
    %le  = SLE <@i64> %i %to
    BRANCH2 %le %body %exit
    
%body:
    %sum2 = ADD <@i64> %sum %i
    %i2   = ADD <@i64> %i 1
    BRANCH %head
    //%montrap = TRAP <@void> %head %head KEEPALIVE (%from %to %sum %i %le %sum2 %i2)

%exit:
    %exittrap = TRAP <@void> %exit %exit KEEPALIVE (%sum) // should stop thread
    RETVOID // unreachable
}